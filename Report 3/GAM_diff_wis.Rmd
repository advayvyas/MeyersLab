---
title: "GAM_diff_wis"
output: html_document
---


```{r data}
library(dplyr)
library(lubridate)
library(tidyr)
library(caret)
library(purrr)
library(fastDummies)
library(GGally)
```

## 1. Load data
```{r}
df <- readr::read_csv("GBQR_diff_wis.csv", show_col_types = FALSE)
```



## GAM
```{r}

df_season <- df %>%
  filter(season == "2023/24")


ggpairs(df_season %>%
          ungroup() %>%
          mutate(log_density_state = log(density_state),
                 log_density_hsa = log(density_hsa),
                 log_population_state = log(population_state),
                 log_population_hsa = log(population_hsa)) %>%
          select(diff_wis_h1, diff_wis_h2, diff_wis_h3, diff_wis_h4, 
                 pop_ratio, pct_urban, log_density_state, log_density_hsa, 
                 log_population_state, log_population_hsa),
        lower = list(continuous = wrap("points", alpha=0.6, size=1.5)),
        upper = list(continuous = wrap("cor", size=4)),
        diag  = list(continuous = wrap("densityDiag")))



library(mgcv) 
fit_gam <- gam(diff_wis_h3 ~ s(pop_ratio) + s(pct_urban) + 
                 s(log(density_state)) + s(log(density_hsa)) +
                 s(log(population_state)) + s(log(population_hsa)),
               data = df_season)

summary(fit_gam)
plot(fit_gam, pages=1, shade=TRUE)


fit_gam2 <- gam(diff_wis_h3 ~ pop_ratio + 
                  s(pct_urban) + 
                  log(density_state) + 
                  s(log(density_hsa)) + 
                  s(log(population_state)) + 
                  log(population_hsa),
                data = df_season)
summary(fit_gam2)
plot(fit_gam2, pages=1, shade=TRUE)

fit_final <- gam(
  diff_wis_h3 ~ s(pct_urban) +
                 s(log(density_hsa)) +
                 s(log(population_state)),
  data = df_season
)
summary(fit_final)
plot(fit_final, pages=1, shade=TRUE)
# Partial effect plots for the three predictors retained in the final GAM: proportion urban (pct\_urban), HSA-level population density, and state-level population size (both log-transformed).
gam.check(fit_final)

df_fitted <- data.frame(fitted = fit_final$fitted.values, observed = fit_final$y)
ggplot(df_fitted, aes(x = fitted, y = observed)) +
    geom_point(alpha = 0.6) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") 

cor(df_fitted$fitted, df_fitted$observed, use = "complete.obs")^2

df_diag <- data.frame(
  fitted = fitted(fit_final),
  residuals = resid(fit_final, type = "deviance"),
  standardized = resid(fit_final, type = "pearson")
)

# Residuals vs Fitted
ggplot(df_diag, aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(x = "Fitted values", y = "Deviance residuals")

# QQ-plot
qqnorm(df_diag$residuals)
qqline(df_diag$residuals, col = "red")
```


Generalized additive model (GAM) analysis of HSA-level vs. state-level forecasting performance.
Negative values of diff_wis_h3 indicate that HSA-level forecasts have lower WIS (better performance) than state-level forecasts.
 


### Add more regions where data doesn't exit
```{r}
library(tigris)
library(stringr)
us_map <- readRDS("us_map_pop_sf.rds")

df_250K <- us_map %>%
  filter(population_hsa >= 250000) %>%
  select(state, hsa_nci_id, population_hsa, population_state, density_state,
         density_hsa, pct_urban, pop_ratio, geometry_hsa, geometry) %>%
  distinct() %>%
  distinct() %>%
  left_join(df_season %>%
              ungroup() %>%
              filter(season == '2023/24') %>%
              select(state, hsa_nci_id, diff_wis_h1, diff_wis_h2, diff_wis_h3, 
                     diff_wis_h4),
            by = c("state", "hsa_nci_id"))

pred <- predict(
  fit_final,
  newdata = data.frame(
    pct_urban = df_250K$pct_urban,
    density_hsa      = df_250K$density_hsa,       
  population_state = df_250K$population_state   
    ),
  type = "response",
  se.fit = TRUE
)

df_pred <- df_250K %>%
  mutate(
    diff_wis_h3_hat = as.numeric(pred$fit),
    se_hat          = as.numeric(pred$se.fit),
    lwr95           = diff_wis_h3_hat - 1.96 * se_hat,
    upr95           = diff_wis_h3_hat + 1.96 * se_hat
  )




```

## Figures
```{r}

df_val <- df_pred %>% filter(is.finite(diff_wis_h3))

# coverage ()
coverage_95 <- mean(df_val$diff_wis_h3 >= df_val$lwr95 & df_val$diff_wis_h3 <= df_val$upr95, na.rm = TRUE)
coverage_95
message(sprintf("95%% coverage = %.1f%% (n=%d)", 100*coverage_95, nrow(df_val)))

ggplot(df_val, aes(x = diff_wis_h3_hat, y = diff_wis_h3)) +
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width = 0, alpha = 0.35) +
  geom_point(alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  labs(x = "Predicted diff_wis_h3", y = "Observed diff_wis_h3",
       title = "Observed vs Predicted with 95% Prediction Intervals",
       subtitle = sprintf("95%% coverage = %.1f%% (n=%d)", 100*coverage_95, nrow(df_val))) +
  theme_minimal()




```


Observed vs. predicted values of diff\_wis\_h3 with 95\% prediction intervals (coverage = 52\%), illustrating that broad population variables explain a substantial but incomplete share of the variation ($R^2_{\mathrm{adj}}=0.455$).


## Add US map

```{r}

library(ggplot2)
library(sf)

#all_inc <- read.csv("Local-level-forecasting/data/hsa_state_inc.csv")
all_inc <- readr::read_csv("hsa_state_inc.csv", show_col_types = FALSE)


avail_hsa <- all_inc %>%
  select(state, hsa_nci_id, week_end) %>%
  group_by(state, hsa_nci_id) %>%
  summarise(max_week_end = max(week_end),
            min_week_end = min(week_end),
            n = n()) %>%
  filter(max_week_end == '2025-07-26')

lower48 <- c(state.name, "District of Columbia")  # 48 states  + DC
lower48 <- setdiff(lower48, c("Alaska", "Hawaii")) # not include Alaska and Hawaii

df_conus <- df_pred %>% 
  filter(state %in% lower48) %>%
  mutate(available = ifelse(is.na(diff_wis_h3), 1, 0))



us_map1 <- us_map %>% 
  filter(state %in% lower48) %>%
  left_join(avail_hsa %>%
              filter(n == 148), by = c("state", "hsa_nci_id")) %>%
  mutate(available = ifelse(is.na(n), 0, 1))




ggplot() +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry_hsa"),
          aes(fill = factor(available)), color = 'gray20') +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry"),
          fill = NA, color = "grey20", linewidth = 0.25) +
  scale_fill_manual(values = c("0" = "white", "1" = "skyblue"),
                    name = "",
                    labels = c("Not in Data", "HSA in Data")) +
  coord_sf() + 
  theme_void() +
  theme(
    legend.text  = element_text(size = 20)
  )

ggplot() +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(df_conus), "geometry_hsa"),
          aes(fill = diff_wis_h3), color = 'gray20') +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry_hsa"),
          fill = NA, color = 'gray20') +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry"),
          fill = NA, color = "grey20", linewidth = 0.25) +
  scale_fill_viridis_c(option = "magma", direction = 1, na.value = "white",
                       name = "diff wis h3") + 
  coord_sf() + theme_void() +
  labs(title = "diff wis h3")

unavail_hsa <- us_map1 %>%
  as.data.frame() %>%              # 혹시 tibble이면 sf 변환 위해
  sf::st_as_sf() %>%
  sf::st_set_geometry("geometry_hsa") %>%
  dplyr::filter(available == 0, population_hsa > 250000)



ggplot() +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(df_conus), "geometry_hsa"),
          aes(fill = diff_wis_h3_hat), color = 'gray20') +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry"),
          fill = NA, color = "grey20", linewidth = 0.25) +
  geom_sf(data = sf::st_set_geometry(sf::st_as_sf(us_map1), "geometry_hsa"),
          fill = NA, color = 'gray20') +
  geom_sf(data = unavail_hsa,
          fill = NA, color = "red", linewidth = 0.5) +
  scale_fill_viridis_c(option = "magma", direction = 1, na.value = "white",
                       name = "Prediction", 
                       limits = c(min(df_pred$diff_wis_h3, na.rm = TRUE),
                                  max(df_pred$diff_wis_h3, na.rm = TRUE))) +
  coord_sf() + theme_void() +
  labs(title = "Prediction")


```

Observed diff\_wis\_h3 mapped across HSAs, where darker shades (more negative values) represent greater HSA-level advantage.
Out-of-sample predictions for HSAs with population $\geq$ 250{,}000, with yellow outlines indicating regions that were not included in model fitting due to lack of ED visit data.


## GLM

```{r}

fit_glm <- glm(diff_wis_h3~pop_ratio + pct_urban + 
    log(density_state) + log(density_hsa) +
    log(population_state) + log(population_hsa),
      data = df_season,
      family = gaussian(link = "identity")
    )
step(fit_glm)


step_glm <- glm(diff_wis_h3 ~ pct_urban + log(density_hsa) + log(population_state),
      data = df_season,
      family = gaussian(link = "identity")
    )
summary(step_glm)
#plot(step_glm)


df_fitted <- data.frame(fitted = step_glm$fitted.values, observed = step_glm$y)
ggplot(df_fitted, aes(x = fitted, y = observed)) +
    geom_point(alpha = 0.6) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") 

cor(df_fitted$fitted, df_fitted$observed, use = "complete.obs")^2
```


